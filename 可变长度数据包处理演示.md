# 可变长度数据包处理演示

## 🎯 演示目标

展示如何使用新的环形缓冲区系统来处理不同类型的串口数据包，确保只有完整的数据包才会被处理。

## 📦 支持的数据包类型

### 1. 开机响应包 (4字节)
```
字节: 0x68 0x00 0x01 0x55
说明: 包头 + 包长度(1) + 命令类型(开机响应)
```

### 2. 查询ID响应包 (7字节)
```
字节: 0x68 0x00 0x04 0x02 0x01 0x02 0x03
说明: 包头 + 包长度(4) + 命令类型(查询ID) + 设备ID(3字节)
```

### 3. 定位数据包 (45字节)
```
字节: 0x68 0x00 0x2A 0xCC [42字节定位数据]
说明: 包头 + 包长度(42) + 命令类型(定位数据) + 定位信息
```

## 🔧 使用方法

### 基本设置
```java
// 创建USBSerialManager实例
USBSerialManager manager = new USBSerialManager(pluginContext, hostContext);

// 设置数据接收监听器
manager.setListener(new USBSerialListener() {
    @Override
    public void onDataReceived(byte[] data) {
        // data 保证是完整的数据包
        handleCompletePacket(data);
    }
    
    @Override
    public void onDeviceConnected(UsbDevice device) {
        Log.d(TAG, "Device connected: " + device.getDeviceName());
    }
    
    @Override
    public void onDeviceDisconnected() {
        Log.d(TAG, "Device disconnected");
    }
    
    @Override
    public void onError(Exception error) {
        Log.e(TAG, "Serial error", error);
    }
});
```

### 数据包处理
```java
private void handleCompletePacket(byte[] packet) {
    if (packet.length < 4) {
        Log.w(TAG, "Packet too short: " + packet.length + " bytes");
        return;
    }
    
    // 验证包头
    int header = ((packet[0] & 0xFF) << 8) | (packet[1] & 0xFF);
    if (header != 0x0068) {
        Log.w(TAG, "Invalid packet header: 0x" + Integer.toHexString(header).toUpperCase());
        return;
    }
    
    // 解析包信息
    int packetDataLength = packet[2] & 0xFF;
    int commandType = packet[3] & 0xFF;
    int totalLength = packetDataLength + 3;
    
    Log.d(TAG, String.format("Packet: DataLen=%d, Cmd=0x%02X, Total=%d", 
            packetDataLength, commandType, totalLength));
    
    // 根据命令类型处理
    switch (commandType) {
        case 0x55: // 开机响应
            handlePowerOnResponse(packet);
            break;
            
        case 0x02: // 查询ID响应
            handleIdQueryResponse(packet);
            break;
            
        case 0xCC: // 定位数据
            handleLocationData(packet);
            break;
            
        default:
            Log.w(TAG, "Unknown command type: 0x" + Integer.toHexString(commandType).toUpperCase());
            break;
    }
}
```

### 具体处理函数
```java
private void handlePowerOnResponse(byte[] packet) {
    Log.d(TAG, "🔋 Device power-on response received");
    // 处理开机响应逻辑
    // 例如：更新UI状态、发送查询命令等
}

private void handleIdQueryResponse(byte[] packet) {
    Log.d(TAG, "🆔 Device ID query response received");
    
    if (packet.length >= 7) {
        // 提取设备ID (字节4-6)
        byte[] deviceId = new byte[3];
        System.arraycopy(packet, 4, deviceId, 0, 3);
        
        String idString = String.format("%02X%02X%02X", 
                deviceId[0] & 0xFF, deviceId[1] & 0xFF, deviceId[2] & 0xFF);
        Log.d(TAG, "Device ID: " + idString);
        
        // 处理设备ID逻辑
    }
}

private void handleLocationData(byte[] packet) {
    Log.d(TAG, "📍 Location data received");
    
    if (packet.length >= 45) {
        // 提取定位数据 (字节4-45)
        byte[] locationData = new byte[42];
        System.arraycopy(packet, 4, locationData, 0, 42);
        
        // 解析定位信息
        parseLocationInfo(locationData);
    }
}

private void parseLocationInfo(byte[] data) {
    // 根据你的定位数据格式解析
    // 例如：经纬度、时间戳、状态信息等
    Log.d(TAG, "Location data: " + data.length + " bytes");
    
    // 这里添加具体的定位数据解析逻辑
    // 例如：
    // double latitude = parseLatitude(data);
    // double longitude = parseLongitude(data);
    // long timestamp = parseTimestamp(data);
}
```

## 🧪 测试验证

### 运行测试
```java
// 在需要的地方调用测试
RingBufferTest.runAllTests();
```

### 测试输出示例
```
🧪 Starting RingBuffer basic functionality test
✅ Test 1 - Written 4 bytes
✅ Test 1 - Has complete packet: 4 bytes
✅ Test 1 - Successfully read complete packet
✅ Test 1 - Packet header verified
🧪 Test 2 - Testing fragmented packet writing
📝 Written first part (32 bytes)
✅ Test 2 - Has complete packet after first part: false
📝 Written second part (13 bytes)
✅ Test 2 - Has complete packet after second part: 45 bytes
✅ Test 2 - Successfully read fragmented packet
✅ Test 2 - Packet structure verified
🧪 Test 3 - Testing multiple packet types
📝 Written power-on packet (4 bytes)
📝 Written ID query packet (7 bytes)
📝 Written location packet (45 bytes)
📦 Read packet 1 (4 bytes)
  → Power-on response
📦 Read packet 2 (7 bytes)
  → ID query response
📦 Read packet 3 (45 bytes)
  → Location data
✅ Test 3 - Successfully processed 3 packets
🎉 RingBuffer test completed
```

## 📊 性能特点

### 处理效率
- **自动识别**: 无需手动指定数据包长度
- **完整性保证**: 只有完整数据包才会被处理
- **分片处理**: 自动处理分片接收的数据
- **内存优化**: 智能的缓冲区管理

### 错误处理
- **包头验证**: 自动验证包头标识
- **长度检查**: 确保数据包长度正确
- **异常安全**: 完善的错误处理机制
- **日志记录**: 详细的调试信息

## 🎉 优势总结

1. **自动化处理**: 无需手动管理数据包边界
2. **类型识别**: 自动识别不同类型的数据包
3. **稳定性**: 避免分片数据导致的处理错误
4. **扩展性**: 易于添加新的数据包类型
5. **调试友好**: 丰富的日志和状态信息

---

**使用建议**: 
- 在 `onDataReceived` 回调中直接处理完整数据包
- 使用命令类型来区分不同的数据包
- 利用日志输出来调试数据包处理过程
- 根据实际需求扩展数据包解析逻辑
